# dk_service_can_provider

> **Overview**
> This Docker service provides CAN bus communication based on CAN signals defined in `.dbc` files and VSS (Vehicle Signal Specification) signals. It bridges CAN bus messages with KUKSA databroker for vehicle data management.

## üìë Table of Contents

- [üé® Design Phase](#-design-phase)
  - [Design Workflow](#design-workflow)
  - [Input Files (User-Designed)](#input-files-user-designed)
  - [Output Files (Auto-Generated)](#output-files-auto-generated)
  - [Signal Types](#signal-types)
  - [Generation Script](#generation-script)
  - [Example dbc_overlay.vspec](#example-dbc_overlayvspec)
- [üéØ Development Scenarios & Workflows](#-development-scenarios--workflows)
  - [üìã Scenario Overview](#-scenario-overview)
  - [üñ•Ô∏è Scenario 1: Local Development (x86_64)](#Ô∏è-scenario-1-local-development-x86_64)
  - [üíª Scenario 2: ARM Development (Jetson Orin)](#-scenario-2-arm-development-jetson-orin)
  - [üöÄ Scenario 3: Production Deployment (k3s)](#-scenario-3-production-deployment-k3s)
  - [üåê Scenario 4: Marketplace Release](#-scenario-4-marketplace-release)
- [üõ†Ô∏è Build Script Reference](#Ô∏è-build-script-reference)
- [üìä Service Management](#-service-management)
- [üîß Configuration Reference](#-configuration-reference)
- [üß™ Testing & Validation](#-testing--validation)
- [üîç Troubleshooting](#-troubleshooting)
- [üìö File Structure](#-file-structure)
- [üöÄ Quick Reference](#-quick-reference)

---

## üé® Design Phase

### Design Workflow

Before deploying the service, you need to design the VSS-to-CAN mapping and vice-versa:
Details can be found from https://github.com/eclipse-kuksa/kuksa-can-provider/blob/main/mapping/README.md

```
1. Design Input Files          2. Generate Mappings        3. Deploy Service
   (Manual)                        (Automated)                 (Runtime)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ dbc_overlay     ‚îÇ            ‚îÇ                 ‚îÇ         ‚îÇ                 ‚îÇ
‚îÇ   .vspec        ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ    ./vss.sh     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  Docker         ‚îÇ
‚îÇ (USER DESIGN)   ‚îÇ       ‚îÇ    ‚îÇ                 ‚îÇ         ‚îÇ  Container      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ             ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ             ‚îú‚îÄ‚ñ∫ vss_dbc.json
‚îÇ ModelCAN.dbc    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îÇ   (VSS mapping)
‚îÇ (USER PROVIDED) ‚îÇ                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                     ‚îî‚îÄ‚ñ∫ dbc_default_values.json
                                            (CAN defaults)
```

### Input Files (User-Designed)

| File | Purpose | Example |
|------|---------|---------|
| `prepare-dbc-file/mapping/vss_4.0/dbc_overlay.vspec` | Define VSS-to-CAN signal mappings | See [dbc_overlay.vspec example](#example-dbc_overlayvspec) |
| `prepare-dbc-file/ModelCAN.dbc` | CAN database with message/signal definitions | Standard DBC format |

### Output Files (Auto-Generated)

| File | Purpose | Generated By |
|------|---------|--------------|
| `prepare-dbc-file/mapping/vss_4.0/vss_dbc.json` | Runtime VSS-DBC mapping | `./vss.sh` (vspec2json.py) |
| `prepare-dbc-file/mapping/dbc_default_values.json` | Default values for all CAN signals in actuator messages | `./vss.sh` (DBC parser) |

### Signal Types

#### SENSOR (CAN ‚Üí VSS)
Read-only signals from CAN bus to VSS databroker.

**Use Case:** Vehicle speed sensor reading from CAN bus displayed in UI

```yaml
# dbc_overlay.vspec
Vehicle.Speed:
  type: sensor
  datatype: float
  dbc2vss:
    signal: DI_uiSpeed          # CAN signal from ModelCAN.dbc
    interval_ms: 500            # Update every 0.5 seconds
```

**Test Workflow:**
```bash
# 1. Send CAN message (ID: 0x257, bit 24-32)
cansend vcan0 257#0000000001000000
cansend vcan0 257#0000000100000000

# 2. Monitor in KUKSA
kuksa-client grpc://127.0.0.1:55555
subscribe Vehicle.Speed
# ‚úì Value updates to 256
# ‚úì Value updates to 1
```

#### ACTUATOR (VSS ‚Üí CAN)
Writable signals from VSS databroker to CAN bus.

**Use Case:** User toggles low beam headlights from UI, sent to CAN bus

```yaml
# dbc_overlay.vspec
Vehicle.Body.Lights.Beam.Low.IsOn:
  type: actuator
  datatype: boolean
  vss2dbc:
    signal: DAS_lowBeamRequest  # CAN signal from ModelCAN.dbc
    transform:
      mapping:
        - from: true
          to: DAS_HEADLIGHT_REQUEST_ON      # Enum value from DBC
        - from: false
          to: DAS_HEADLIGHT_REQUEST_OFF     # Enum value from DBC
```

**Test Workflow:**
```bash
# 1. Set value in KUKSA
kuksa-client grpc://127.0.0.1:55555
setTargetValue Vehicle.Body.Lights.Beam.Low.IsOn true

# 2. Monitor CAN bus
candump vcan0
# ‚úì Observe: 3E9#0100000000000000 (ID: 0x3E9)
```

### Generation Script

**Prerequisites:**
```bash
pip3 install -r requirements.txt
```

**Generate mappings:**
```bash
./vss.sh          # Run Development Workflow
./vss.sh -h       # Show detailed help
```

**What `./vss.sh` does:**

1. **Clone VSS Repository** (if not present)
   - Repository: `https://github.com/COVESA/vehicle_signal_specification`
   - Branch: `4.X`
   - Location: `dreamKIT/vehicle_signal_specification/`
   - Includes: `vss-tools` submodule

2. **Generate `vss_dbc.json`**
   - Input: `dbc_overlay.vspec` + VSS specification
   - Tool: `vspec2json.py` from vss-tools
   - Output: `prepare-dbc-file/mapping/vss_4.0/vss_dbc.json`

3. **Generate `dbc_default_values.json`**
   - Parse `dbc_overlay.vspec` for all actuator signals
   - Find CAN messages containing those signals in `ModelCAN.dbc`
   - Extract **all** signals from those CAN messages
   - Create JSON with default value `0` for each signal

**Example: HVAC Fan Speed Actuator**

Given `dbc_overlay.vspec`:
```yaml
Vehicle.Cabin.HVAC.Station.Row1.Driver.FanSpeed:
  datatype: int8
  type: actuator
  vss2dbc:
    signal: VCRIGHT_hvacBlowerSpeedRPMReq
```

And `ModelCAN.dbc`:
```dbc
BO_ 524 ID20CVCRIGHT_hvacRequest: 8 VehicleBus
 SG_ VCRIGHT_conditioningRequest : 12|1@1+ (1,0) [0|1] ""  Receiver
 SG_ VCRIGHT_hvacBlowerSpeedRPMReq : 32|10@1+ (5,0) [0|5115] "RPM"  Receiver
 SG_ VCRIGHT_hvacEvapEnabled : 11|1@1+ (1,0) [0|1] ""  Receiver
 SG_ VCRIGHT_tempEvaporator : 13|11@1+ (0.1,-40) [-40|105] "C"  Receiver
 ...
```

Generated `dbc_default_values.json`:
```json
{
  "VCRIGHT_conditioningRequest" : 0,
  "VCRIGHT_hvacBlowerSpeedRPMReq" : 0,
  "VCRIGHT_hvacEvapEnabled" : 0,
  "VCRIGHT_tempEvaporator" : 0,
  ...
}
```

> **Note:** All signals from the CAN message `ID20CVCRIGHT_hvacRequest` are included because it contains the actuator signal `VCRIGHT_hvacBlowerSpeedRPMReq`.

### Example dbc_overlay.vspec

Complete example with multiple signal types:

```yaml
# Actuator: Low Beam Headlights (boolean with enum mapping)
Vehicle.Body.Lights.Beam.Low.IsOn:
  type: actuator
  datatype: boolean
  vss2dbc:
    signal: DAS_lowBeamRequest
    transform:
      mapping:
        - from: true
          to: DAS_HEADLIGHT_REQUEST_ON
        - from: false
          to: DAS_HEADLIGHT_REQUEST_OFF

# Actuator: Hazard Lights (boolean with enum mapping)
Vehicle.Body.Lights.Hazard.IsSignaling:
  type: actuator
  datatype: boolean
  vss2dbc:
    signal: DAS_hazardLightRequest
    transform:
      mapping:
        - from: true
          to: DAS_REQUEST_HAZARDS_ON
        - from: false
          to: DAS_REQUEST_HAZARDS_OFF

# Actuator: High Beam (boolean, direct mapping)
Vehicle.Body.Lights.Beam.High.IsOn:
  type: actuator
  datatype: boolean
  vss2dbc:
    signal: DAS_highBeamRequest

# Actuator: Seat Position (integer, range 0-10)
Vehicle.Cabin.Seat.Row1.DriverSide.Position:
  datatype: int8
  type: actuator
  vss2dbc:
    signal: VCRIGHT_frontSeatTrackForward

# Actuator: HVAC Fan Speed Driver (integer, RPM)
Vehicle.Cabin.HVAC.Station.Row1.Driver.FanSpeed:
  datatype: int8
  type: actuator
  vss2dbc:
    signal: VCRIGHT_hvacBlowerSpeedRPMReq

# Actuator: HVAC Fan Speed Passenger (integer, RPM)
Vehicle.Cabin.HVAC.Station.Row1.Passenger.FanSpeed:
  datatype: int8
  type: actuator
  vss2dbc:
    signal: VCLEFT_hvacBlowerRPMTarget
```

---

## üéØ Development Scenarios & Workflows

Choose the workflow that matches your development environment and goals:

### üìã Scenario Overview

| Scenario | Environment | Architecture | Use Case | Workflow |
|----------|-------------|--------------|----------|----------|
| **Local Dev (x86)** | Ubuntu x86_64 | amd64 | Development & Testing | [Local Development](#-scenario-1-local-development-x86_64) |
| **Local Dev (ARM)** | Jetson Orin | arm64 | Native ARM Testing | [ARM Development](#-scenario-2-arm-development-jetson-orin) |
| **Production** | k3s Cluster | arm64 | Production Deployment | [Production Deployment](#-scenario-3-production-deployment-k3s) |
| **Marketplace** | Public Release | arm64 | Public Distribution | [Marketplace Release](#-scenario-4-marketplace-release) |

---

## üñ•Ô∏è Scenario 1: Local Development (x86_64)

**When to use:** Developing and testing on Ubuntu x86_64 with virtual CAN

### Prerequisites
- Ubuntu x86_64 system
- Docker installed
- KUKSA databroker running on localhost:55555
- CAN utilities: `sudo apt install can-utils`

### Workflow
```bash
# 1. Build for current architecture (auto-detected)
./build.sh local

# 2. Start development environment
./start.sh local

# 3. Test the service
kuksa-client grpc://127.0.0.1:55555
# Test commands:
setTargetValue Vehicle.Body.Lights.Beam.Low.IsOn true

# 4. Monitor CAN traffic
candump vcan0

# 5. Stop when done
./stop.sh local
```

### Configuration
- **KUKSA Address:** `localhost:55555`
- **CAN Interface:** `vcan0` (virtual)
- **VSS Mapping:** `mapping/vss_4.0/vss_dbc.json`
- **Architecture:** Auto-detected (amd64)

---

## üíª Scenario 2: ARM Development (Jetson Orin)

**When to use:** Testing directly on ARM64 hardware before production deployment

### Prerequisites
- Jetson Orin with Ubuntu ARM64
- Docker installed
- KUKSA databroker running
- Physical CAN interface or virtual CAN

### Workflow
```bash
# 1. Build for current architecture (ARM64 auto-detected)
./build.sh local

# 2. Start with virtual CAN for testing
./start.sh local

# OR start with physical CAN
docker run -d -it --name dk_service_can_provider --net=host --privileged \
  -e KUKSA_ADDRESS=localhost \
  -e CAN_PORT=can1 \
  -e MAPPING_FILE=mapping/vss_4.0/vss_dbc.json \
  dk_service_can_provider:latest

# 3. Test the service
kuksa-client grpc://127.0.0.1:55555

# 4. Monitor CAN traffic
candump can1  # or vcan0

# 5. Stop when done
./stop.sh local
```

### Configuration
- **KUKSA Address:** `localhost:55555`
- **CAN Interface:** `can1` (physical) or `vcan0` (virtual)
- **VSS Mapping:** `mapping/vss_4.0/vss_dbc.json`
- **Architecture:** ARM64 (auto-detected)

---

## üöÄ Scenario 3: Production Deployment (k3s)

**When to use:** Deploying to production k3s cluster with distributed nodes

### Prerequisites
- k3s cluster running
- Jetson Orin as master (192.168.56.48)
- S32G as agent node with CAN interface
- kubectl configured

### Option A: Using Pre-built Image (Recommended)
```bash
# 1. Build and push to GitHub Container Registry
./build.sh prod --push

# 2. Deploy to k3s (pulls from GHCR)
kubectl apply -f manifests/mirror-remote.yaml    # Pull image to local registry
kubectl apply -f manifests/deployment.yaml # Deploy service
kubectl apply -f manifests/service.yaml   # Create service

# 3. Monitor deployment
kubectl get pods -l app=dk-service-can-provider
kubectl logs -f -l app=dk-service-can-provider

# 4. Test the service
kuksa-client grpc://192.168.56.48:55555
```

### Option B: Using Local Image Import
```bash
# 1. Build for production
./build.sh prod

# 2. Import to k3s and deploy
./start.sh prod --import

# 3. Monitor deployment
./start.sh prod --status
```

### Option C: Manual Image Import (Your Method)
```bash
# 1. Build production image
./build.sh prod

# 2. Save and import image
docker save dk_service_can_provider:latest > dk_service_can_provider.tar
sudo k3s ctr images import dk_service_can_provider.tar
rm dk_service_can_provider.tar

# 3. Deploy manifests
kubectl apply -f manifests/mirror-local.yaml
kubectl apply -f manifests/deployment.yaml
```

### Configuration
- **KUKSA Address:** `192.168.56.48:55555`
- **CAN Interface:** `can1` (physical on S32G)
- **VSS Mapping:** `mapping/vss_4.0/vss_dbc.json`
- **Architecture:** ARM64
- **Node Assignment:** Service runs on `vip` node

---

## üåê Scenario 4: Marketplace Release

**When to use:** Publishing to Digital Auto Marketplace for public distribution

### Prerequisites
- Tested and validated service
- GitHub Container Registry access
- Digital Auto Marketplace account

### Workflow
```bash
# 1. Build and test locally (ARM64)
./build.sh local  # On Jetson Orin

# 2. Build and push production image
./build.sh prod v1.0.0 --push

# 3. Verify image is public
docker pull ghcr.io/eclipse-autowrx/dk_service_can_provider:v1.0.0

# 4. Submit to marketplace with template
```

### Marketplace Template
```json
{
  "Target": "vip",
  "Platform": "linux/arm64",
  "DockerImageURL": "ghcr.io/eclipse-autowrx/dk_service_can_provider:latest",
  "RuntimeCfg": {
    "CAN_PORT": "can1",
    "MAPPING_FILE": "mapping/vss_4.0/vss_dbc.json",
    "KUKSA_ADDRESS": "192.168.56.48"
  }
}
```

### Configuration
- **Public Image:** `ghcr.io/eclipse-autowrx/dk_service_can_provider:latest`
- **Target Node:** `vip` (agent node with CAN access)
- **Platform:** `linux/arm64`
- **Runtime Config:** Production settings

---

## üõ†Ô∏è Build Script Reference

### Commands
```bash
# Auto-detect architecture and build for local development
./build.sh local [version]

# Build for production (ARM64) deployment
./build.sh prod [version] [--push]

# Build for both environments
./build.sh both [version]
```

### Architecture Detection
- **x86_64 ‚Üí linux/amd64** (Ubuntu development)
- **aarch64/arm64 ‚Üí linux/arm64** (Jetson Orin/Production)

### Examples
```bash
./build.sh local              # Current arch, latest tag
./build.sh local v1.0.0       # Current arch, specific version
./build.sh prod               # ARM64, latest tag
./build.sh prod v1.0.0 --push # ARM64, push to GHCR
./build.sh both               # Both architectures
```

---

## üìä Service Management

### Start Service
```bash
./start.sh local              # Local development
./start.sh prod               # Production deployment
./start.sh prod --import      # Import image and deploy
./start.sh [env] --status     # Check status
```

### Stop Service
```bash
./stop.sh local               # Stop local container
./stop.sh prod                # Stop k3s deployment
./stop.sh [env] --cleanup     # Stop and cleanup
./stop.sh [env] --force       # Force stop
```

### Monitor Service
```bash
# Local
docker logs -f dk_service_can_provider
candump vcan0

# Production
kubectl logs -f -l app=dk-service-can-provider
kubectl get pods -l app=dk-service-can-provider
```

---

## üîß Configuration Reference

### Environment Variables

| Variable | Local | Production | Description |
|----------|-------|------------|-------------|
| `KUKSA_ADDRESS` | `localhost` | `192.168.56.48` | KUKSA databroker address |
| `CAN_PORT` | `vcan0` | `can1` | CAN interface name |
| `MAPPING_FILE` | `mapping/vss_3.0/vss_dbc.json` | `mapping/vss_4.0/vss_dbc.json` | VSS mapping file |
| `LOG_LEVEL` | `INFO` | `INFO` | Logging verbosity |
| `DBC_FILE` | `ModelCAN.dbc` | `ModelCAN.dbc` | DBC definition file |

### Network Architecture

```
Development (Local):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Developer     ‚îÇ    ‚îÇ   Docker     ‚îÇ    ‚îÇ   KUKSA         ‚îÇ
‚îÇ   Machine       ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ   Container  ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ   Databroker    ‚îÇ
‚îÇ   (vcan0)       ‚îÇ    ‚îÇ              ‚îÇ    ‚îÇ   (localhost)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Production (k3s):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   S32G          ‚îÇ    ‚îÇ   k3s Pod    ‚îÇ    ‚îÇ   Jetson Orin   ‚îÇ
‚îÇ   (can0/can1)   ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ   (vip node) ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ   KUKSA Server  ‚îÇ
‚îÇ                 ‚îÇ    ‚îÇ              ‚îÇ    ‚îÇ   (192.168.56.48)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üß™ Testing & Validation

> **Note:** For detailed signal test workflows, see the [Design Phase](#-design-phase) section.

### Quick Test Commands

**Connect to KUKSA:**
```bash
# Local development
kuksa-client grpc://127.0.0.1:55555

# Production (k3s cluster)
kuksa-client grpc://192.168.56.48:55555
```

**Test Actuators (VSS ‚Üí CAN):**
```bash
# Light controls
setTargetValue Vehicle.Body.Lights.Beam.Low.IsOn true
setTargetValue Vehicle.Body.Lights.Beam.High.IsOn false
setTargetValue Vehicle.Body.Lights.Hazard.IsSignaling true

# Seat position (range: 0-10)
setTargetValue Vehicle.Cabin.Seat.Row1.DriverSide.Position 5

# HVAC fan speed
setTargetValue Vehicle.Cabin.HVAC.Station.Row1.Driver.FanSpeed 75
setTargetValue Vehicle.Cabin.HVAC.Station.Row1.Passenger.FanSpeed 50
```

**Test Sensors (CAN ‚Üí VSS):**
```bash
# Subscribe to vehicle speed
subscribe Vehicle.Speed

# In another terminal, send CAN message
cansend vcan0 257#0000000001000000
```

**Monitor CAN Bus:**
```bash
# Monitor all CAN traffic
candump vcan0        # Local development
candump can1         # Production (physical CAN)

# Monitor specific message
candump vcan0,3E9:7FF
```

---

## üîç Troubleshooting

### Common Issues

#### 1. Architecture Mismatch
```bash
# Check current architecture
uname -m

# Rebuild for correct architecture
./build.sh local
```

#### 2. CAN Interface Issues
```bash
# Check CAN interface
ip link show can1        # Physical
ip link show vcan0       # Virtual

# Create virtual CAN
sudo modprobe vcan
sudo ip link add dev vcan0 type vcan
sudo ip link set up vcan0
```

#### 3. KUKSA Connection Issues
```bash
# Test KUKSA connectivity
telnet 192.168.56.48 55555  # Production
telnet localhost 55555      # Local

# Check KUKSA logs
docker logs sdv-runtime
```

#### 4. k3s Deployment Issues
```bash
# Check k3s status
sudo systemctl status k3s

# Check node status
kubectl get nodes

# Check pod logs
kubectl logs -l app=dk-service-can-provider

# Check image import
sudo k3s ctr images ls | grep dk_service_can_provider
```

#### 5. Mirror Job Issues
```bash
# Check mirror job logs
kubectl logs job/mirror-dk-service-can-provider

# Manually verify image
sudo k3s ctr images ls | grep localhost:5000/dk_service_can_provider
```

---

## üìö File Structure

```
dk_service_can_provider/
‚îú‚îÄ‚îÄ README.md                             # This file
‚îú‚îÄ‚îÄ DEPLOYMENT.md                         # Detailed deployment guide
‚îú‚îÄ‚îÄ Dockerfile                            # Container definition
‚îú‚îÄ‚îÄ requirements.txt                      # Python dependencies for vss.sh
‚îÇ
‚îú‚îÄ‚îÄ Design Phase Scripts
‚îú‚îÄ‚îÄ vss.sh                                # VSS mapping generation script
‚îÇ
‚îú‚îÄ‚îÄ Deployment Scripts
‚îú‚îÄ‚îÄ build.sh                              # Build Docker images
‚îú‚îÄ‚îÄ start.sh                              # Start service (local/prod)
‚îú‚îÄ‚îÄ stop.sh                               # Stop service (local/prod)
‚îÇ
‚îú‚îÄ‚îÄ Design Input Files (User-Designed)
‚îú‚îÄ‚îÄ prepare-dbc-file/
‚îÇ   ‚îú‚îÄ‚îÄ ModelCAN.dbc                      # INPUT: CAN database (user-provided)
‚îÇ   ‚îú‚îÄ‚îÄ mapping/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ vss_4.0/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dbc_overlay.vspec         # INPUT: VSS-to-CAN mapping (user-designed)
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Design Output Files (Auto-Generated)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ vss_dbc.json                  # OUTPUT: Runtime VSS-DBC mapping
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dbc_default_values.json       # OUTPUT: Default CAN signal values
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ createvcan.sh                     # Virtual CAN setup utility
‚îÇ
‚îú‚îÄ‚îÄ Runtime Configuration
‚îú‚îÄ‚îÄ mapping/                              # VSS mapping files for runtime
‚îÇ   ‚îú‚îÄ‚îÄ vss_3.0/                         # VSS 3.x mappings (alternative)
‚îÇ   ‚îî‚îÄ‚îÄ vss_4.0/                         # VSS 4.x mappings (default)
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ dbc_feeder.ini                    # DBC feeder configuration
‚îÇ
‚îî‚îÄ‚îÄ Kubernetes Deployment
    ‚îî‚îÄ‚îÄ manifests/
        ‚îú‚îÄ‚îÄ mirror-local.yaml             # Local image mirror job
        ‚îú‚îÄ‚îÄ mirror-remote.yaml            # Remote image mirror job (GHCR)
        ‚îú‚îÄ‚îÄ deployment.yaml               # k3s deployment
        ‚îî‚îÄ‚îÄ service.yaml                  # k3s service
```

### File Categories

| Category | Files | Purpose |
|----------|-------|---------|
| **Design Inputs** | `dbc_overlay.vspec`, `ModelCAN.dbc` | User designs VSS-CAN mappings |
| **Design Outputs** | `vss_dbc.json`, `dbc_default_values.json` | Auto-generated by `./vss.sh` |
| **Runtime Config** | `mapping/`, `config/` | Used by Docker container at runtime |
| **Deployment** | `build.sh`, `start.sh`, `stop.sh`, `manifests/` | Build and deploy service |

---

## üöÄ Quick Reference

### Development Workflow

```bash
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Phase 1: Design VSS-to-CAN Mapping
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

# 1. Design your dbc_overlay.vspec file
vim prepare-dbc-file/mapping/vss_4.0/dbc_overlay.vspec

# 2. Generate mapping files
pip3 install -r requirements.txt
./vss.sh

# 3. Verify generated files
cat prepare-dbc-file/mapping/vss_4.0/vss_dbc.json
cat prepare-dbc-file/mapping/dbc_default_values.json

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Phase 2: Development & Testing
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

# 4. Build for your architecture
./build.sh local              # Auto-detect (x86_64 or ARM64)

# 5. Start service
./start.sh local              # Local development

# 6. Test signals
kuksa-client grpc://127.0.0.1:55555
setTargetValue Vehicle.Body.Lights.Beam.Low.IsOn true

# 7. Monitor CAN bus
candump vcan0

# 8. Stop when done
./stop.sh local

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Phase 3: Production Deployment
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

# 9. Build for production (ARM64)
./build.sh prod

# 10. Deploy to k3s
./start.sh prod --import      # Import and deploy

# 11. Monitor in production
kubectl logs -f -l app=dk-service-can-provider
candump can1

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Phase 4: Marketplace Release
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

# 12. Create versioned release
./build.sh prod v1.0.0 --push

# 13. Submit to Digital Auto Marketplace
# Use GHCR URL: ghcr.io/eclipse-autowrx/dk_service_can_provider:v1.0.0
```

### Essential Commands

| Task | Command |
|------|---------|
| **Design** | `./vss.sh` |
| **Build Local** | `./build.sh local` |
| **Build Production** | `./build.sh prod` |
| **Test Local** | `./start.sh local` |
| **Deploy Production** | `./start.sh prod --import` |
| **Monitor Logs** | `docker logs -f dk_service_can_provider` (local)<br>`kubectl logs -f -l app=dk-service-can-provider` (prod) |
| **Test Signals** | `kuksa-client grpc://127.0.0.1:55555` |
| **Monitor CAN** | `candump vcan0` (local)<br>`candump can1` (prod) |

---

This comprehensive guide ensures you can successfully design, develop, test, and deploy the dk_service_can_provider service across all scenarios and environments.